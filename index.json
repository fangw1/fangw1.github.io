[{"content":"Zet操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 查看zset有多少数据 ZCARD homemarket:realTimeTrans # 输出zset数据详情 ZRANGE homemarket:realTimeTrans 0 -1 withscores # 移除指定元素 ZREMRANGEBYRANK homemarket:realTimeTrans 3 3 # 移除所有元素 ZREMRANGEBYRANK homemarket:realTimeTrans 0 -1 # 增加元素， 需要用双引号可以避免中文反序列化问题。时间-8小时 ZADD homemarket:realTimeTrans 1718789470278 \u0026#34;{\\\u0026#34;@class\\\u0026#34;:\\\u0026#34;xxx$TransVO\\\u0026#34;,\\\u0026#34;type\\\u0026#34;:\\\u0026#34;facPolicy\\\u0026#34;,\\\u0026#34;transNo\\\u0026#34;:\\\u0026#34;xx000000003\\\u0026#34;,\\\u0026#34;transDate\\\u0026#34;:[\\\u0026#34;java.util.Date\\\u0026#34;,\\\u0026#34;2024-06-12T11:00:08.257+00:00\\\u0026#34;],\\\u0026#34;iconZh\\\u0026#34;:\\\u0026#34;2024\\x88\\x86\\\u0026#34;,\\\u0026#34;iconEn\\\u0026#34;:\\\u0026#34;2024Policy\\\u0026#34;,\\\u0026#34;premium\\\u0026#34;:\\\u0026#34;xxx\\\u0026#34;}\u0026#34; 参考：菜鸟教程\n","permalink":"https://www.fangw.online/posts/tech/redis/redis-zset-cli/","summary":"Zet操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 查看zset有多少数据 ZCARD homemarket:realTimeTrans # 输出zset数据详情 ZRANGE homemarket:realTimeTrans 0 -1 withscores # 移除指定元素 ZREMRANGEBYRANK homemarket:realTimeTrans 3 3 # 移除所有元素 ZREMRANGEBYRANK","title":"Redis Zset Cli"},{"content":"MAC 14.2.1 刷新dns 1 sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder 设置dns 1 networksetup -setdnsservers Wi-Fi 140.205.81.23 8.8.8.8 114.114.114.114 ","permalink":"https://www.fangw.online/posts/tech/common_tools/","summary":"MAC 14.2.1 刷新dns 1 sudo dscacheutil -flushcache; sudo killall -HUP mDNSResponder 设置dns 1 networksetup -setdnsservers Wi-Fi 140.205.81.23 8.8.8.8 114.114.114.114","title":"常用工具脚本"},{"content":"分布式锁的几种实现 背景 在分布式系统中，当某个资源可以被多个系统访问使用到的时候，为了保证大家访问这个数据是一致性的，那么就要求再同一个时刻，只能被一个系统使用，这个时候就需要分布式锁。\n分布式和集群的区别 定义的区别\n计算机集群（英语：computer cluster）是一组松散或紧密连接在一起工作的计算机。由于这些计算机协同工作，在许多方面它们可以被视为单个系统。与网格计算机不同，计算机集群将每个节点设置为执行相同的任务，由软件控制和调度。\n维基百科的解释，关键词是：一组计算机、相同的任务。\n分布式系统是一组电脑，透过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。[1]组件之间彼此进行交互以实现一个共同的目标。把需要进行大量计算的工程数据分割成小块，由多台计算机分别计算，再上传运算结果后，将结果统一合并得出数据结论的科学。\n维基百科的解释，关键词是：一组计算机、大计算分解\n集群的关键作用是提升并发处理能力 分布式的关键作用是解耦以便于快速迭代 分布式锁应该具备哪些条件 在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行 高可用的获取锁与释放锁 高性能的获取锁与释放锁 具备可重入特性 具备锁失效机制，防止死锁 具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败 实现 定义接口 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * 分布式锁顶级接口 * * @author : fangwei * @date : 2019/9/23 0:48 */ public interface DistributedLock { /** * 获取锁 * * @param key KEY * @throws Exception 异常 */ void acquire(String key) throws Exception; /** * 获取锁 * * @param key KEY * @param maxWait 最大等待时间 * @param waitUnit 等待时间单位 * @return 成功/失败 * @throws Exception 异常 */ boolean acquire(String key, long maxWait, TimeUnit waitUnit) throws Exception; /** * 释放锁 * * @param key KEY * @throws Exception 异常 */ void release(String key) throws Exception; } ZooKeeper 分布式锁实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * Distributed Lock http://curator.apache.org//getting-started.html * * @author : fangwei * @date : 2020/5/29 15:02 */ public class ZkDistributedLock implements DistributedLock { private final CuratorFramework client; public ZkDistributedLock(CuratorFramework client) { this.client = client; } @Override public void acquire(String key) throws Exception { InterProcessMutex lock = new InterProcessMutex(client, key); lock.acquire(); } @Override public boolean acquire(String key, long maxWait, TimeUnit waitUnit) throws Exception { InterProcessMutex lock = new InterProcessMutex(client, key); return lock.acquire(maxWait, waitUnit); } @Override public void release(String key) throws Exception { InterProcessMutex lock = new InterProcessMutex(client, key); lock.release(); } } 定义CuratorFramework 1 2 3 4 5 6 7 8 9 10 11 12 /** * initMethod start 相当于执行 client.start() * * @return CuratorFramework */ @Bean(initMethod = \u0026#34;start\u0026#34;) @ConditionalOnMissingBean public CuratorFramework curatorFramework(CuratorProperties curatorProperties) { RetryPolicy retryPolicy = new ExponentialBackoffRetry(curatorProperties.getBaseSleepTimeMs(), curatorProperties.getMaxRetries()); return CuratorFrameworkFactory.newClient(curatorProperties.getZookeeperConnectionString(), retryPolicy); } 1 2 3 4 5 6 7 8 9 10 11 12 13 /** * zk curator 配置 * * @author : fangwei * @date : 2020/1/22 9:18 */ @Data @ConfigurationProperties(prefix = \u0026#34;curator\u0026#34;) public class CuratorProperties { private int baseSleepTimeMs = 1000; private int maxRetries = 3; private String zookeeperConnectionString; } Redisson 分布式锁实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * Redisson 分布式R锁 - 可重入锁 * * @author : fangwei * @date : 2020/4/28 10:30 */ public class RedissonDistributedRLock implements DistributedLock { private final RedissonClient redissonClient; public RedissonDistributedRLock(RedissonClient redissonClient) { this.redissonClient = redissonClient; } @Override public void acquire(String key) { // 可重入锁（Reentrant Lock） RLock lock = redissonClient.getLock(key); lock.lock(); } @Override public boolean acquire(String key, long maxWait, TimeUnit waitUnit) throws Exception { // 可重入锁（Reentrant Lock） RLock lock = redissonClient.getLock(key); return lock.tryLock(maxWait, waitUnit); } @Override public void release(String key) { // 可重入锁（Reentrant Lock） RLock lock = redissonClient.getLock(key); lock.unlock(); } } 使用示例 属性设置 1 2 3 curator.zookeeper-connection-string = zk链接地址 curator.base-sleep-time-ms = 1000 curator.max-retries = 3 注入bean 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @Autowired private CuratorFramework client; @Bean public DistributedLock distributedLock() { return new ZkDistributedLock(client); } // 或者使用Redisson @Autowired private RedissonClient redissonClient; @Bean public DistributedLock distributedLock() { return new RedissonDistributedRLock(redissonClient); } Recipes 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Autowired private DistributedLock lock; if ( lock.acquire(maxWait, waitUnit) ) { try { // do some work inside of the critical section here } finally { lock.release(); } } 总结 如果后期用户需要切换分布式锁的实现，只需要调整依赖的bean的注入即可 常见问题 使用Redisson分布式锁时，出现 unlock 异常 异常信息如下：\n1 attempt to unlock lock, not locked by current thread by node id: 84ed3ba0-f34c-4ffd-afbf-882e775f6cd 解决办法: 在解锁之前，判断当前key对应的锁是否已被锁定并且是否被当前线程保持，代码如下：\n1 2 3 if (lock.isLocked() \u0026amp;\u0026amp; lock.isHeldByCurrentThread()) { lock.unlock(); } ","permalink":"https://www.fangw.online/posts/tech/distributed-lock/","summary":"分布式锁的几种实现 背景 在分布式系统中，当某个资源可以被多个系统访问使用到的时候，为了保证大家访问这个数据是一致性的，那么就要求再同一个时刻，","title":"Distributed Lock"},{"content":"","permalink":"https://www.fangw.online/posts/blog/blog/","summary":"","title":"Blog"},{"content":"","permalink":"https://www.fangw.online/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://www.fangw.online/posts/read/read/","summary":"","title":"Read"},{"content":"For test\n","permalink":"https://www.fangw.online/posts/tech/tech/","summary":"For test","title":"Tech"},{"content":"生成订单30分钟未支付，则自动取消，该怎么实现？ 在开发中，往往会遇到一些关于延时任务的需求。例如\n生成订单30分钟未支付，则自动取消 生成订单60秒后,给用户发短信 对上述的任务，我们给一个专业的名字来形容，那就是延时任务。那么这里就会产生一个问题，这个延时任务和定时任务的区别究竟在哪里呢？一共有如下几点区别\n定时任务有明确的触发时间，延时任务没有 定时任务有执行周期，而延时任务在某事件触发后一段时间内执行，没有执行周期 定时任务一般执行的是批处理操作是多个任务，而延时任务一般是单个任务 一般实现的方法有几种：\n使用 rocketmq、rabbitmq、pulsar 等消息队列的延时投递功能 使用 redisson 提供的 DelayedQueue 有一些方案虽然广为流传但存在着致命缺陷，不要用来实现延时任务\n使用 redis 的过期监听 使用 rabbitmq 的死信队列 使用非持久化的时间轮 数据库轮询 👍 数据量，并发量并不大的系统，可以使用这个方案。\n该方案通常是在小型项目中使用，即通过一个线程定时的去扫描数据库，通过订单时间来判断是否有超时的订单，然后进行update或delete等操作。\n优点: 简单易行，支持集群操作 缺点: (1)对服务器内存消耗大 (2)存在延迟，比如你每隔3分钟扫描一次，那最坏的延迟时间就是3分钟 (3)假设你的订单有几千万条，每隔几分钟这样扫描一次，数据库损耗极大 JDK的延迟队列 🙊 该方案是利用JDK自带的DelayQueue来实现，这是一个无界阻塞队列，该队列只有在延迟期满的时候才能从中获取元素，放入DelayQueue中的对象，是必须实现Delayed接口的。\n优点: 效率高,任务触发时间延迟低。 缺点: (1)服务器重启后，数据全部消失，怕宕机 (2)集群扩展相当麻烦 (3)因为内存条件限制的原因，比如下单未付款的订单数太多，那么很容易就出现OOM异常 (4)代码复杂度较高 时间轮算法 🙊 时间轮是一种很优秀的定时任务的数据结构，然而绝大多数时间轮实现是纯内存没有持久化的。\nredis缓存过期监听 🙊 Redis 官方手册的keyspace-notifications: timing-of-expired-events中明确指出：\nBasically expired events are generated when the Redis server deletes the key and not when the time to live theoretically reaches the value of zero\nredis 自动过期的实现方式是：定时任务离线扫描并删除部分过期键；在访问键时惰性检查是否过期并删除过期键。redis 从未保证会在设定的过期时间立即删除并发送过期通知。实际上，过期通知晚于设定的过期时间数分钟的情况也比较常见。\n此外键空间通知采用的是发送即忘(fire and forget)策略，并不像消息队列一样保证送达。当订阅事件的客户端会丢失所有在断线期间所有分发给它的事件。\nRedission RDelayedQueue redisson delayqueue 是一种基于 redis zset 结构的延时队列实现。delayqueue 中有一个名为 timeoutSetName 的有序集合，其中元素的 score 为投递时间戳。delayqueue 会定时使用 zrangebyscore 扫描已到投递时间的消息，然后把它们移动到就绪消息列表中。\ndelayqueue 保证 redis 不崩溃的情况下不会丢失消息，在没有更好的解决方案时不妨一试。\n在数据库索引设计良好的情况下，定时扫描数据库中未完成的订单产生的开销并没有想象中那么大。在使用 redisson delayqueue 等定时任务中间件时可以同时使用扫描数据库的方法作为补偿机制，避免中间件故障造成任务丢失。\n基于 Redis 实现延迟队列\n消息队列 👍 优点: 高效,可以利用消息队列的分布式特性轻易的进行横向扩展,消息支持持久化增加了可靠性。 缺点：依赖消息队列，复杂度和成本变高 RocketMQ 实现 Kafka 实现 ","permalink":"https://www.fangw.online/posts/tech/auto_cancel/","summary":"生成订单30分钟未支付，则自动取消，该怎么实现？ 在开发中，往往会遇到一些关于延时任务的需求。例如 生成订单30分钟未支付，则自动取消 生成订单6","title":"订单自动取消"},{"content":" Patrick\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Patrick\u0026rsquo;s Blog 网址： http://www.fangw.online 图标： img/Q.png 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n","permalink":"https://www.fangw.online/links/","summary":"Patrick\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Patrick\u0026rsquo;s Blog 网址： http://www.fangw.online 图标： img/Q.png 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文","title":"🤝友链"},{"content":"关于我\n英文名: Patrick 职业: 程序员 运动: 跑步、乒乓球、LOL ","permalink":"https://www.fangw.online/about/","summary":"关于我 英文名: Patrick 职业: 程序员 运动: 跑步、乒乓球、LOL","title":"🙋🏻‍♂️关于"},{"content":"for test\n","permalink":"https://www.fangw.online/posts/read/mysql/","summary":"for test","title":""}]